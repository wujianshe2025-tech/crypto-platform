<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é’±åŒ…è¿æ¥æµ‹è¯•</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen p-8">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold mb-8">ğŸ§ª é’±åŒ…è¿æ¥æµ‹è¯•</h1>

    <!-- çŠ¶æ€æ˜¾ç¤º -->
    <div id="status" class="mb-8 p-4 bg-gray-800 rounded-lg">
      <h2 class="text-xl font-semibold mb-2">çŠ¶æ€</h2>
      <p id="status-text" class="text-gray-400">æœªè¿æ¥</p>
    </div>

    <!-- æµ‹è¯•æŒ‰é’® -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
      <button onclick="testMetaMask()" class="bg-blue-600 hover:bg-blue-700 p-4 rounded-lg">
        1. æ£€æŸ¥MetaMask
      </button>
      <button onclick="connectWallet()" class="bg-green-600 hover:bg-green-700 p-4 rounded-lg">
        2. è¿æ¥é’±åŒ…
      </button>
      <button onclick="signMessage()" class="bg-purple-600 hover:bg-purple-700 p-4 rounded-lg">
        3. ç­¾åæ¶ˆæ¯
      </button>
      <button onclick="loginToBackend()" class="bg-yellow-600 hover:bg-yellow-700 p-4 rounded-lg">
        4. ç™»å½•åç«¯
      </button>
      <button onclick="checkMembership()" class="bg-pink-600 hover:bg-pink-700 p-4 rounded-lg">
        5. æ£€æŸ¥ä¼šå‘˜çŠ¶æ€
      </button>
      <button onclick="becomeMember()" class="bg-red-600 hover:bg-red-700 p-4 rounded-lg">
        6. æˆä¸ºä¼šå‘˜
      </button>
    </div>

    <!-- æ—¥å¿—æ˜¾ç¤º -->
    <div class="bg-gray-800 rounded-lg p-4">
      <h2 class="text-xl font-semibold mb-2">æ—¥å¿—</h2>
      <div id="logs" class="space-y-2 font-mono text-sm"></div>
    </div>
  </div>

  <script>
    const API_URL = (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'))
      ? 'http://localhost:3000'
      : 'https://crypto-platform-api.vercel.app';
    const USDT_ADDRESS = '0x55d398326f99059fF775485246999027B3197955';
    const PLATFORM_ADDRESS = '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb';
    
    let currentAddress = null;
    let currentSignature = null;
    let currentMessage = null;
    let currentToken = null;

    function log(message, type = 'info') {
      const logs = document.getElementById('logs');
      const colors = {
        info: 'text-blue-400',
        success: 'text-green-400',
        error: 'text-red-400',
        warning: 'text-yellow-400'
      };
      const timestamp = new Date().toLocaleTimeString();
      logs.innerHTML = `<div class="${colors[type]}">[${timestamp}] ${message}</div>` + logs.innerHTML;
    }

    function updateStatus(text) {
      document.getElementById('status-text').textContent = text;
    }

    async function testMetaMask() {
      log('æ£€æŸ¥MetaMask...', 'info');
      
      if (typeof window.ethereum === 'undefined') {
        log('âŒ MetaMaskæœªå®‰è£…', 'error');
        updateStatus('âŒ MetaMaskæœªå®‰è£…');
        return false;
      }
      
      log('âœ… MetaMaskå·²å®‰è£…', 'success');
      updateStatus('âœ… MetaMaskå·²å®‰è£…');
      return true;
    }

    async function connectWallet() {
      log('è¿æ¥é’±åŒ…...', 'info');
      
      if (!await testMetaMask()) return;

      try {
        const accounts = await window.ethereum.request({ 
          method: 'eth_requestAccounts' 
        });
        currentAddress = accounts[0];
        log(`âœ… é’±åŒ…å·²è¿æ¥: ${currentAddress}`, 'success');
        updateStatus(`âœ… å·²è¿æ¥: ${currentAddress.slice(0, 6)}...${currentAddress.slice(-4)}`);
        return true;
      } catch (error) {
        log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 'error');
        return false;
      }
    }

    async function signMessage() {
      log('è¯·æ±‚ç­¾å...', 'info');
      
      if (!currentAddress) {
        log('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
        return;
      }

      try {
        currentMessage = `æ¬¢è¿ç™»å½•è¿½é£è§‚æµ‹\n\næ—¶é—´: ${new Date().toISOString()}\nåœ°å€: ${currentAddress}`;
        
        currentSignature = await window.ethereum.request({
          method: 'personal_sign',
          params: [currentMessage, currentAddress]
        });
        
        log(`âœ… ç­¾åæˆåŠŸ`, 'success');
        log(`ç­¾å: ${currentSignature.slice(0, 20)}...`, 'info');
        return true;
      } catch (error) {
        log(`âŒ ç­¾åå¤±è´¥: ${error.message}`, 'error');
        return false;
      }
    }

    async function loginToBackend() {
      log('ç™»å½•åç«¯...', 'info');
      
      if (!currentAddress || !currentSignature) {
        log('âŒ è¯·å…ˆå®Œæˆç­¾å', 'error');
        return;
      }

      try {
        const response = await fetch(`${API_URL}/api/auth/wallet-login`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            address: currentAddress,
            message: currentMessage,
            signature: currentSignature
          })
        });

        const data = await response.json();
        
        if (data.success) {
          currentToken = data.token;
          log(`âœ… ç™»å½•æˆåŠŸ`, 'success');
          log(`ç”¨æˆ·å: ${data.user.username}`, 'info');
          log(`ä¼šå‘˜çŠ¶æ€: ${data.user.isMember ? 'âœ… ä¼šå‘˜' : 'âŒ éä¼šå‘˜'}`, 'info');
          updateStatus(`âœ… å·²ç™»å½•: ${data.user.username}`);
          return true;
        } else {
          log(`âŒ ç™»å½•å¤±è´¥: ${data.error}`, 'error');
          return false;
        }
      } catch (error) {
        log(`âŒ ç™»å½•å¤±è´¥: ${error.message}`, 'error');
        return false;
      }
    }

    async function checkMembership() {
      log('æ£€æŸ¥ä¼šå‘˜çŠ¶æ€...', 'info');
      
      if (!currentToken) {
        log('âŒ è¯·å…ˆç™»å½•', 'error');
        return;
      }

      try {
        const response = await fetch(`${API_URL}/api/membership/status`, {
          headers: {
            'Authorization': `Bearer ${currentToken}`
          }
        });

        const data = await response.json();
        
        if (data.success) {
          log(`âœ… ä¼šå‘˜çŠ¶æ€: ${data.isMember ? 'ä¼šå‘˜' : 'éä¼šå‘˜'}`, 'success');
          if (data.isMember) {
            log(`æˆä¸ºä¼šå‘˜æ—¶é—´: ${new Date(data.membershipDate).toLocaleString()}`, 'info');
          }
          return true;
        } else {
          log(`âŒ æŸ¥è¯¢å¤±è´¥: ${data.error}`, 'error');
          return false;
        }
      } catch (error) {
        log(`âŒ æŸ¥è¯¢å¤±è´¥: ${error.message}`, 'error');
        return false;
      }
    }

    async function becomeMember() {
      log('æˆä¸ºä¼šå‘˜...', 'warning');
      log('âš ï¸  è¿™å°†å‘èµ·çœŸå®çš„USDTè½¬è´¦ï¼', 'warning');
      
      if (!currentToken) {
        log('âŒ è¯·å…ˆç™»å½•', 'error');
        return;
      }

      if (!confirm('ç¡®å®šè¦æ”¯ä»˜1 USDTæˆä¸ºä¼šå‘˜å—ï¼Ÿ')) {
        log('âŒ ç”¨æˆ·å–æ¶ˆ', 'info');
        return;
      }

      try {
        log('åˆå§‹åŒ–Web3...', 'info');
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        
        const USDT_ABI = [
          'function transfer(address to, uint256 amount) returns (bool)',
          'function balanceOf(address account) view returns (uint256)'
        ];
        
        const contract = new ethers.Contract(USDT_ADDRESS, USDT_ABI, signer);
        
        log('æ£€æŸ¥ä½™é¢...', 'info');
        const balance = await contract.balanceOf(currentAddress);
        const balanceFormatted = ethers.utils.formatUnits(balance, 18);
        log(`USDTä½™é¢: ${balanceFormatted}`, 'info');
        
        if (parseFloat(balanceFormatted) < 1) {
          log('âŒ USDTä½™é¢ä¸è¶³', 'error');
          return;
        }
        
        log('å‘èµ·è½¬è´¦...', 'info');
        const amount = ethers.utils.parseUnits('1', 18);
        const tx = await contract.transfer(PLATFORM_ADDRESS, amount);
        
        log(`âœ… äº¤æ˜“å·²å‘é€: ${tx.hash}`, 'success');
        log('ç­‰å¾…ç¡®è®¤...', 'info');
        
        const receipt = await tx.wait();
        log(`âœ… äº¤æ˜“å·²ç¡®è®¤ï¼ŒåŒºå—: ${receipt.blockNumber}`, 'success');
        
        log('æ¿€æ´»ä¼šå‘˜...', 'info');
        const response = await fetch(`${API_URL}/api/membership/activate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentToken}`
          },
          body: JSON.stringify({
            txHash: receipt.transactionHash,
            blockNumber: receipt.blockNumber
          })
        });

        const data = await response.json();
        
        if (data.success) {
          log(`âœ… æ­å–œæˆä¸ºä¼šå‘˜ï¼`, 'success');
          updateStatus('âœ… ä¼šå‘˜ç”¨æˆ·');
          return true;
        } else {
          log(`âŒ æ¿€æ´»å¤±è´¥: ${data.error}`, 'error');
          return false;
        }
      } catch (error) {
        log(`âŒ æ”¯ä»˜å¤±è´¥: ${error.message}`, 'error');
        return false;
      }
    }

    // é¡µé¢åŠ è½½æ—¶çš„æç¤º
    log('ğŸ§ª æµ‹è¯•é¡µé¢å·²åŠ è½½', 'success');
    log('è¯·æŒ‰é¡ºåºç‚¹å‡»æŒ‰é’®è¿›è¡Œæµ‹è¯•', 'info');
  </script>
</body>
</html>
